% required Data
md_inv = loadmodel('Models/Model_kangerlussuaq_budd.mat');
md.transient.ismovingfront = 1;

%% Interpolating mask
disp('   Interpolating mask');

%% set ice levelset corresponding to lia
tmp_levelset = ExpToLevelSet(md.mesh.x, md.mesh.y, 'Exp/first_front.exp');
pos = tmp_levelset(1:end-1) > 0;  % positive distances
md.mask.ice_levelset(pos) = -1;

disp('      reading LIA surface');
md.geometry.surface = interpLiaSurface(md.mesh.x, md.mesh.y);
pos = find(md.mask.ice_levelset > 0);
md.geometry.surface(pos) = md.geometry.base(pos) + 10; %Minimum thickness

md.geometry.thickness = md.geometry.surface - md.geometry.bed;
pos=find(md.geometry.thickness <= 10);
md.geometry.surface(pos) = md.geometry.base(pos) + 10; %Minimum thickness
md.geometry.thickness = md.geometry.surface - md.geometry.bed;
md.masstransport.min_thickness = 10;

%% The floating part at the front is different, so we will fix this
% Floating condition see "Ralfe Greve, Heinz Blatter - Dynamics Of Ice Sheets And Glaciers (2009)"
% rho * H = rho_w * (z_sl - h), where h is ice surface and z_sl is z wrt sea level. (eq. 6.44).
% from equation (6.57) we find that H/b <= rho_w / rho_i = 1.1
condition1 =  md.geometry.thickness ./ abs(md.geometry.bed)<=1.1;
condition2 = md.mask.ocean_levelset<0; % it is within the fjord, condtion 1 also true in non-glacier areas for some reason.
% condition3 = ContourToNodes(md.mesh.x, md.mesh.y, 'Exp/first_front.exp'); % doesn't matter because the remaining stuff is outside ice levelset
pos = find(condition1 & condition2);
md.geometry.thickness(pos) = md.materials.rho_water / (md.materials.rho_ice - md.materials.rho_water) * md.geometry.surface(pos);
plotmodel(md, 'data', md.geometry.thickness, 'figure', 34, 'expdisp', 'ice_front.exp') 

%% Ice mask adjustment
disp('   Adjusting ice mask');
% Offset the mask by one element so that we don't end up with a cliff at the transition
max_elem = max(md.mask.ice_levelset(md.mesh.elements), [], 2); % find max in each row
pos = find(max_elem > 0);
md.mask.ice_levelset(md.mesh.elements(pos, :)) = 1;

% For the region where surface is NaN, set thickness to small value (consistency requires >0)
pos = find((md.mask.ice_levelset < 0) .* (md.geometry.surface < 0));
md.mask.ice_levelset(pos) = 1;
pos = find((md.mask.ice_levelset < 0) .* (isnan(md.geometry.surface)));
md.mask.ice_levelset(pos) = 1;

%% Reconstruct thickness
disp('      -- reconstruct thickness');
% set ice thickness in ocean to 0 (outside domain of interest)
% front_area_pos = find(ContourToNodes(md.mesh.x, md.mesh.y, '/data/eigil/work/lia_kq/Exp/no_ice/no_ice.exp', 2));
% md.geometry.surface(front_area_pos) = 0;  

md.geometry.thickness = md.geometry.surface - md.geometry.base;
plotmodel(md, 'data', md.geometry.thickness, 'figure', 35, 'expdisp', 'ice_front.exp') 

% set boundary conditions
% pos = find((md.mask.ice_levelset < 0) .* (md.mesh.vertexonboundary));
% md.stressbalance.spcvx(pos) = md.initialization.vx(pos);
% md.stressbalance.spcvy(pos) = md.initialization.vy(pos);
% md.stressbalance.spcvz(pos) = 0;

% set transient boundary spc thickness
md.masstransport.spcthickness = NaN(md.mesh.numberofvertices + 1, 2); 
pos = find(md.mesh.vertexonboundary);
md.masstransport.spcthickness(pos, :) = [md.geometry.thickness(pos), md_inv.geometry.thickness(pos)];
md.masstransport.spcthickness(end, :) = [1900, 2007];
